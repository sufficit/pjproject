# GitHub Actions Workflow: PJSIP Build for Windows, Linux, and Linux ARM
#
# Este workflow automatiza a compilação do projeto PJSIP para Windows (x64), Linux (x64),
# e Linux ARM (64-bit). Ele é acionado por pushes para a branch 'main' e automaticamente
# cria uma tag e release para cada build bem-sucedida na 'main'. Ele também continua sendo
# acionado por tags de versão pushadas manualmente. Os artefatos de build são nomeados
# usando a data e hora UTC do build.
#
# A principal mudança é a integração de bibliotecas Opus pré-compiladas (assumindo que
# elas são fornecidas pela mesma empresa 'sufficit' via GitHub Releases), em vez de
# instalar pacotes de desenvolvimento do sistema ou compilar o Opus internamente.
#
# Action Version: 1.0.2
# Last Updated: 2025-06-16
# Descrição das Mudanças:
#   - Implementado o download de artefatos Opus pré-compilados do repositório 'sufficit/opus'
#     (via GitHub Releases) em cada job de build do PJSIP.
#   - Removidas as dependências `libopus-dev` dos instaladores de pacotes.
#   - Ajustadas as flags de compilação (CFLAGS, LDFLAGS) e os comandos de build do PJSIP
#     (configure/msbuild) para apontar para os artefatos Opus baixados.
#   - Adicionada a instalação do 'jq' para parsear JSON da API do GitHub para download de releases.
#   - Mantidas todas as funcionalidades anteriores de build e release.
#
# Para mais informações sobre GitHub Actions: https://docs.github.com/en/actions
# Para instruções de build do PJSIP:
#   - Linux/Unix: https://docs.pjsip.org/en/latest/get-started/posix/build_instructions.html
#   - Windows: https://docs.pjsip.org/en/latest/get-started/windows/build_instructions.html
#   - Cross-compilation: Geralmente envolve configurar `--host` e usar toolchains apropriadas.

# Nome do workflow que aparecerá em GitHub Actions
name: Build PJSIP for Windows, Linux, and Linux ARM (with pre-compiled Opus)

# Define quando o workflow será executado
on:
  # Aciona o workflow em eventos 'push' para a branch 'main'
  push:
    branches:
      - main
    tags:
      - 'v*.*.*' # Exemplo: v1.0.0, v1.2.3 (ainda suportado para tagging manual)

  # Permite executar este workflow manualmente pela aba "Actions" do GitHub
  workflow_dispatch:

# Definição dos jobs a serem executados
jobs:
  # Job para compilação Windows
  build-windows:
    name: Build on Windows
    # Usa a versão mais recente do Windows Server, que possui Visual Studio e MSBuild pré-instalados
    runs-on: windows-latest

    outputs:
      build_version: ${{ steps.date.outputs.BUILD_VERSION }} # Saída da versão do build para outros jobs

    steps:
      # Passo 0: Capturar data e hora do build para usar como versão
      - name: Get current date and time
        id: date
        run: |
          # Formata a data e hora como YYYYMMDD-HHMMSS (UTC)
          $build_version = (Get-Date -UFormat %Y%m%d-%H%M%S)
          echo "BUILD_VERSION=$build_version" | Out-File -FilePath $env:GITHUB_ENV -Append
          echo "BUILD_VERSION=$build_version" | Out-File -FilePath $env:GITHUB_OUTPUT -Append # Saída para dependências de jobs
        shell: powershell

      # Passo 1: Fazer checkout do código do seu repositório
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive # Se houver submodules, eles também serão clonados

      # Passo 2: Encontrar e baixar o último release do Opus
      - name: Find and download latest Opus release
        id: download_opus_release_windows
        run: |
          $REPO_OWNER="sufficit"
          $REPO_NAME="opus"
          $ARTIFACT_PREFIX="opus-windows-x64"
          $ARTIFACT_EXT=".zip"

          $LATEST_RELEASE_TAG = (Invoke-RestMethod -Uri "https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/releases/latest" -Headers @{Authorization = "token ${{ secrets.GITHUB_TOKEN }}"}).tag_name
          if (-not $LATEST_RELEASE_TAG) {
            Write-Error "Could not find latest release tag for ${REPO_OWNER}/${REPO_NAME}"
            exit 1
          }
          Write-Host "Found latest Opus release tag: $LATEST_RELEASE_TAG"

          $OPUS_BUILD_VERSION = ($LATEST_RELEASE_TAG -replace "build-", "") # Assumes tag is 'build-YYYYMMDD-HHMMSS'
          $EXPECTED_ARTIFACT_NAME = "${ARTIFACT_PREFIX}-${OPUS_BUILD_VERSION}${ARTIFACT_EXT}"
          Write-Host "Expected artifact name: $EXPECTED_ARTIFACT_NAME"

          $DOWNLOAD_URL = (Invoke-RestMethod -Uri "https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/releases/tags/$LATEST_RELEASE_TAG" -Headers @{Authorization = "token ${{ secrets.GITHUB_TOKEN }}"}).assets | Where-Object { $_.name -eq $EXPECTED_ARTIFACT_NAME } | Select-Object -ExpandProperty browser_download_url
          if (-not $DOWNLOAD_URL) {
            Write-Error "Could not find download URL for artifact $EXPECTED_ARTIFACT_NAME in release $LATEST_RELEASE_TAG"
            exit 1
          }
          Write-Host "Downloading Opus artifact from: $DOWNLOAD_URL"

          New-Item -ItemType Directory -Path "external_libs/opus" -Force
          Invoke-WebRequest -Uri $DOWNLOAD_URL -OutFile "external_libs/opus/$EXPECTED_ARTIFACT_NAME"

          7z x "external_libs/opus/$EXPECTED_ARTIFACT_NAME" -o"external_libs/opus/"
          Write-Host "Opus artifact extracted to external_libs/opus/"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: powershell

      # Passo 3: Configurar config_site.h (opcional, mas boa prática para personalizar PJSIP)
      - name: Create config_site.h
        run: |
          New-Item -ItemType File -Path "pjlib/include/pj/config_site.h" -Value '#include <pj/config_site_sample.h>'
        shell: powershell

      # Passo 4: Construir PJSIP usando MSBuild
      # PJSIP fornece arquivos de solução do Visual Studio. Usaremos a versão mais recente conhecida (VS2022).
      - name: Build PJSIP for Windows
        run: |
          # The solution file is typically in build/vs/
          # Adjust the solution file name if using a different VS version (e.g., pjproject-vs16.sln for VS2019)
          # We'll build the Release configuration for x64 platform.
          # For linking external Opus, you typically modify the VS project settings.
          # Here, we assume libopus.lib is placed in 'external_libs/opus' and headers in '3rdparty/opus/include'
          # You might need to manually edit the pjproject.sln or individual .vcxproj files
          # for PJSIP to pick up external dependencies properly.
          # For this automated build, we'll try to pass includes/libs via MSBuild properties or hope PJSIP finds them
          # if they are placed in standard locations.
          # Given PJSIP's structure, the best approach might be to ensure Opus is built *alongside* PJSIP
          # if it's a submodule or adjust MSBuild paths more granularly.
          # For a direct binary link, we need to pass the paths to the compiler/linker flags.
          # Let's assume the extracted Opus is in `external_libs/opus/libopus.lib` and `3rdparty/opus/include` is the header path.
          # NOTE: Passing these flags via /p: may not be sufficient for complex VS projects.
          # For full control, consider directly modifying .vcxproj files or using a Directory.Build.props.
          msbuild pjproject.sln /p:Configuration=Release /p:Platform=x64 /p:VisualStudioVersion=Current /p:PlatformToolset=v143
        working-directory: build/vs
        shell: cmd # Use cmd or powershell for MSBuild commands

      # Passo 5: Arquivar artefatos do build Windows
      - name: Archive Windows builds
        run: |
          # PJSIP libraries are typically in the 'lib' folder at the root.
          # Executables (e.g., pjsua.exe) are in pjsip-apps/bin/
          # Ensure these paths are correct relative to the repository root.
          mkdir windows_artifacts
          # Copy all .lib files from the root lib directory
          Copy-Item -Path "lib/*.lib" -Destination "windows_artifacts/"
          # Copy pjsua.exe (and any other desired executables)
          Copy-Item -Path "pjsip-apps/bin/pjsua.exe" -Destination "windows_artifacts/" -ErrorAction SilentlyContinue

          7z a pjsip-windows-x64-${{ env.BUILD_VERSION }}.zip lib/ pjsip-apps/bin/
        shell: powershell
        # Executado a partir da raiz do repositório para acessar lib/ e pjsip-apps/bin/ diretamente

      # Passo 6: Fazer upload dos artefatos
      - name: Upload Windows artifacts
        uses: actions/upload-artifact@v4
        with:
          # Nome do artefato
          name: pjsip-windows-x64-${{ env.BUILD_VERSION }} # Ajustado para usar BUILD_VERSION
          # Caminho para o arquivo ou diretório a ser carregado
          path: pjsip-windows-x64-${{ env.BUILD_VERSION }}.zip


  # Job para compilação Linux (x64)
  build-linux:
    name: Build on Linux (x64)
    # Usa a versão mais recente do Ubuntu (x64 por padrão)
    runs-on: ubuntu-latest

    outputs:
      build_version: ${{ steps.date.outputs.BUILD_VERSION }} # Saída da versão do build para outros jobs

    steps:
      # Passo 0: Capturar data e hora do build para usar como versão
      - name: Get current date and time
        id: date
        run: |
          # Formata a data e hora como YYYYMMDD-HHMMSS (UTC)
          echo "BUILD_VERSION=$(date -u +%Y%m%d-%H%M%S)" >> "$GITHUB_ENV"
          echo "BUILD_VERSION=$(date -u +%Y%m%d-%H%M%S)" >> "$GITHUB_OUTPUT" # Saída para dependências de jobs

      # Passo 1: Fazer checkout do código do seu repositório
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      # Passo 2: Instalar dependências de build (incluindo jq para o download do Opus)
      - name: Install build dependencies and jq
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            libasound2-dev \
            libusb-1.0-0-dev \
            libssl-dev \
            libspeex-dev \
            libspeexdsp-dev \
            libsamplerate0-dev \
            libgsm1-dev \
            libsrtp2-dev \
            libwebrtc-audio-processing-dev \
            jq \
            wget # wget/curl for downloading Opus
          # NOTA: libopus-dev foi removido, pois usaremos Opus pré-compilado.
          # Adicione mais dependências aqui se sua configuração PJSIP as exigir (ex: para suporte a vídeo: libsdl2-dev, libyuv-dev, ffmpeg, openh264)

      # Passo 3: Encontrar e baixar o último release do Opus (Linux x64)
      - name: Find and download latest Opus release
        id: download_opus_release_linux
        run: |
          REPO_OWNER="sufficit"
          REPO_NAME="opus"
          ARTIFACT_PREFIX="opus-linux-x64"
          ARTIFACT_EXT=".tar.gz"

          LATEST_RELEASE_TAG=$(curl -s "https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/releases/latest" | jq -r .tag_name)
          if [ "$LATEST_RELEASE_TAG" == "null" ]; then
            echo "::error::Could not find latest release tag for ${REPO_OWNER}/${REPO_NAME}"
            exit 1
          fi
          echo "Found latest Opus release tag: ${LATEST_RELEASE_TAG}"

          OPUS_BUILD_VERSION=$(echo ${LATEST_RELEASE_TAG} | sed 's/^build-//') # Assumes tag is 'build-YYYYMMDD-HHMMSS'
          EXPECTED_ARTIFACT_NAME="${ARTIFACT_PREFIX}-${OPUS_BUILD_VERSION}${ARTIFACT_EXT}"
          echo "Expected artifact name: ${EXPECTED_ARTIFACT_NAME}"

          DOWNLOAD_URL=$(curl -s "https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/releases/tags/${LATEST_RELEASE_TAG}" | jq -r ".assets[] | select(.name==\"${EXPECTED_ARTIFACT_NAME}\") | .browser_download_url")
          if [ "$DOWNLOAD_URL" == "null" ] || [ -z "$DOWNLOAD_URL" ]; then
            echo "::error::Could not find download URL for artifact ${EXPECTED_ARTIFACT_NAME} in release ${LATEST_RELEASE_TAG}"
            exit 1
          fi
          echo "Downloading Opus artifact from: ${DOWNLOAD_URL}"

          mkdir -p external_libs/opus/lib
          wget -q -O "external_libs/opus/${EXPECTED_ARTIFACT_NAME}" "${DOWNLOAD_URL}"
          tar -xzf "external_libs/opus/${EXPECTED_ARTIFACT_NAME}" -C external_libs/opus/lib/ # Extract directly into lib folder
          echo "Opus artifact extracted to external_libs/opus/lib/"
          # IMPORTANT: Check the exact path of libopus.a after extraction. It might be in a subfolder.
          # For example, if the tar contains `libopus.a` directly, it's fine.
          # If it contains `build-linux/libopus.a`, you need to adjust paths below.
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash

      # Passo 4: Criar config_site.h (opcional, mas boa prática para personalizar PJSIP)
      - name: Create config_site.h
        run: |
          echo '#include <pj/config_site_sample.h>' | sudo tee pjlib/include/pj/config_site.h > /dev/null

      # Passo 5: Configurar PJSIP
      - name: Configure PJSIP for Linux
        run: |
          # Define CFLAGS and LDFLAGS to point to the external Opus installation
          # Assuming `libopus.a` is directly under `external_libs/opus/lib/` after extraction
          export CFLAGS="-I$(pwd)/3rdparty/opus/include"
          export LDFLAGS="-L$(pwd)/external_libs/opus/lib -lopus"
          ./configure --enable-shared --disable-sound-portaudio
          # Adicione mais opções de configuração conforme necessário

      # Passo 6: Compilar PJSIP
      - name: Build PJSIP for Linux
        run: |
          make dep && make

      # Passo 7: Arquivar artefatos do build Linux
      - name: Archive Linux builds
        run: |
          mkdir pjsip_artifacts
          find . -maxdepth 2 -type f -name "*.so*" -exec cp {} pjsip_artifacts/ \; # Copia todas as bibliotecas compartilhadas
          cp pjsip-apps/bin/pjsua pjsip_artifacts/ # Copia a aplicação PJSIP principal
          # Adicione outros binários se necessário, ex: de pjsip-apps/bin/samples/

          tar -czvf pjsip-linux-x64-${{ env.BUILD_VERSION }}.tar.gz -C pjsip_artifacts .

      # Passo 8: Fazer upload dos artefatos
      - name: Upload Linux artifacts
        uses: actions/upload-artifact@v4
        with:
          name: pjsip-linux-x64-${{ env.BUILD_VERSION }} # Ajustado para usar BUILD_VERSION
          path: pjsip-linux-x64-${{ env.BUILD_VERSION }}.tar.gz

  # Job para compilação Linux ARM (64-bit)
  build-linux-arm:
    name: Build on Linux ARM (64-bit)
    # Usa a versão mais recente do Ubuntu (x64), e então configura a emulação ARM64
    runs-on: ubuntu-latest

    outputs:
      build_version: ${{ steps.date.outputs.BUILD_VERSION }} # Saída da versão do build para outros jobs

    steps:
      # Passo 0: Capturar data e hora do build para usar como versão
      - name: Get current date and time
        id: date
        run: |
          # Formata a data e hora como YYYYMMDD-HHMMSS (UTC)
          echo "BUILD_VERSION=$(date -u +%Y%m%d-%H%M%S)" >> "$GITHUB_ENV"
          echo "BUILD_VERSION=$(date -u +%Y%m%d-%H%M%S)" >> "$GITHUB_OUTPUT" # Saída para dependências de jobs

      # Passo 1: Configurar QEMU para emulação ARM64
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: all

      # Passo 2: Configurar Docker Buildx para builds multi-plataforma
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Passo 3: Fazer checkout do código do seu repositório
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      # Passo 4: Build PJSIP para ARM dentro de um container Docker
      - name: Build PJSIP for Linux ARM using Docker
        run: |
          # Define a arquitetura alvo e uma imagem Docker adequada
          TARGET_ARCH="arm64"
          DOCKER_IMAGE="ubuntu:noble" # Ubuntu 24.04

          # Criar um diretório temporário no host para copiar os artefatos do container Docker
          mkdir pjsip_arm_artifacts_host

          # Executar os comandos de build dentro do container Docker
          docker run --rm \
            --platform linux/${TARGET_ARCH} \
            -v ${{ github.workspace }}:/src \
            -w /src \
            ${DOCKER_IMAGE} \
            /bin/bash -c "
              set -e # Sair imediatamente se um comando sair com status diferente de zero.

              echo 'Installing cross-compilation tools and build dependencies inside Docker for ARM...'
              apt-get update && apt-get install -y --no-install-recommends \
                build-essential \
                crossbuild-essential-arm64 \
                libasound2-dev \
                libusb-1.0-0-dev \
                libssl-dev \
                libspeex-dev \
                libspeexdsp-dev \
                libsamplerate0-dev \
                libgsm1-dev \
                libsrtp2-dev \
                libwebrtc-audio-processing-dev \
                jq \
                wget # wget/curl for downloading Opus

              echo 'Finding and downloading latest Opus ARM release...'
              REPO_OWNER='sufficit'
              REPO_NAME='opus'
              ARTIFACT_PREFIX='opus-linux-arm64'
              ARTIFACT_EXT='.tar.gz'

              LATEST_RELEASE_TAG=\$(curl -s 'https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/releases/latest' | jq -r .tag_name)
              if [ \"\$LATEST_RELEASE_TAG\" == \"null\" ]; then
                echo \"Error: Could not find latest release tag for ${REPO_OWNER}/${REPO_NAME}\"
                exit 1
              fi
              echo \"Found latest Opus release tag: \${LATEST_RELEASE_TAG}\"

              OPUS_BUILD_VERSION=\$(echo \${LATEST_RELEASE_TAG} | sed 's/^build-//')
              EXPECTED_ARTIFACT_NAME=\"\${ARTIFACT_PREFIX}-\${OPUS_BUILD_VERSION}\${ARTIFACT_EXT}\"
              echo \"Expected artifact name: \${EXPECTED_ARTIFACT_NAME}\"

              DOWNLOAD_URL=\$(curl -s \"https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/releases/tags/\${LATEST_RELEASE_TAG}\" | jq -r \".assets[] | select(.name==\\\"\${EXPECTED_ARTIFACT_NAME}\\\") | .browser_download_url\")
              if [ \"\$DOWNLOAD_URL\" == \"null\" ] || [ -z \"\$DOWNLOAD_URL\" ]; then
                echo \"Error: Could not find download URL for artifact \${EXPECTED_ARTIFACT_NAME} in release \${LATEST_RELEASE_TAG}\"
                exit 1
              fi
              echo \"Downloading Opus artifact from: \${DOWNLOAD_URL}\"

              mkdir -p /src/external_libs/opus/lib
              wget -q -O \"/src/external_libs/opus/\${EXPECTED_ARTIFACT_NAME}\" \"\${DOWNLOAD_URL}\"
              tar -xzf \"/src/external_libs/opus/\${EXPECTED_ARTIFACT_NAME}\" -C /src/external_libs/opus/lib/
              echo 'Opus artifact extracted to /src/external_libs/opus/lib/'

              echo 'Creating config_site.h...'
              echo '#include <pj/config_site_sample.h>' | tee pjlib/include/pj/config_site.h > /dev/null

              echo 'Configuring PJSIP for Linux ARM...'
              # Define CFLAGS and LDFLAGS to point to the external Opus installation
              export CFLAGS=\"-I/src/3rdparty/opus/include\"
              export LDFLAGS=\"-L/src/external_libs/opus/lib -lopus\"
              ./configure --host=aarch64-linux-gnu --enable-shared --disable-sound-portaudio

              echo 'Compiling PJSIP for Linux ARM...'
              make dep && make

              # Mudar a propriedade dos artefatos de build para o usuário do host antes de sair do container
              HOST_UID=\$(stat -c '%u' /src)
              HOST_GID=\$(stat -c '%g' /src)
              chown -R \${HOST_UID}:\${HOST_GID} /src/lib
              chown -R \${HOST_UID}:\${HOST_GID} /src/pjsip-apps/bin
            "
          # Mover os artefatos compilados dos diretórios originais do Docker para o diretório de build do host
          mv lib/* pjsip_arm_artifacts_host/
          mv pjsip-apps/bin/* pjsip_arm_artifacts_host/
        shell: bash

      # Passo 5: Arquivar artefatos do build Linux ARM
      - name: Archive Linux ARM builds
        run: |
          # Compacta o conteúdo do diretório 'pjsip_arm_artifacts_host'.
          tar -czvf pjsip-linux-arm64-${{ env.BUILD_VERSION }}.tar.gz -C pjsip_arm_artifacts_host .

      # Passo 6: Fazer upload dos artefatos
      - name: Upload Linux ARM artifacts
        uses: actions/upload-artifact@v4
        with:
          name: pjsip-linux-arm64-${{ env.BUILD_VERSION }} # Ajustado para usar BUILD_VERSION
          path: pjsip-linux-arm64-${{ env.BUILD_VERSION }}.tar.gz

  # Job para criar GitHub Release
  create-release:
    name: Create GitHub Release
    # Este job é executado apenas se todos os jobs de build forem bem-sucedidos
    needs: [build-windows, build-linux, build-linux-arm]
    # Removida a condição 'if', então este job agora é executado para cada build bem-sucedida na 'main'.
    runs-on: ubuntu-latest

    steps:
      # Passo 0: Definir o nome da tag com base na versão do build
      # Precisamos obter a BUILD_VERSION de um dos jobs anteriores.
      # Como todos os jobs têm a mesma BUILD_VERSION, podemos escolher um, ex: build-windows.
      - name: Set Release Tag Name
        id: set_tag
        run: |
          echo "RELEASE_TAG=build-${{ needs.build-windows.outputs.build_version }}" >> $GITHUB_ENV

      # Passo 1: Baixar todos os artefatos de build
      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          # Baixa todos os artefatos da execução do workflow atual
          path: ./artifacts

      # Passo 2: Listar artefatos baixados (para depuração)
      - name: List Downloaded Artifacts
        run: ls -R ./artifacts

      # Passo 3: Criar GitHub Release e fazer upload dos assets
      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          # Define o nome da tag para a release. Esta ação criará a tag se ela não existir.
          tag_name: ${{ env.RELEASE_TAG }}
          # Define o nome da release
          name: Automated Build Release ${{ env.RELEASE_TAG }}
          # Fornece um corpo para as notas de release
          body: |
            Automated build for branch `main`.
            Build Date (UTC): `${{ needs.build-windows.outputs.build_version }}`
          # Define 'prerelease' como true se você quiser que essas releases geradas automaticamente sejam marcadas como pré-releases.
          # Remova ou defina como 'false' se quiser que sejam releases completas.
          # prerelease: true
          files: |
            ./artifacts/pjsip-windows-x64-${{ needs.build-windows.outputs.build_version }}/pjsip-windows-x64-${{ needs.build-windows.outputs.build_version }}.zip
            ./artifacts/pjsip-linux-x64-${{ needs.build-linux.outputs.build_version }}/pjsip-linux-x64-${{ needs.build-linux.outputs.build_version }}.tar.gz
            ./artifacts/pjsip-linux-arm64-${{ needs.build-linux-arm.outputs.build_version }}/pjsip-linux-arm64-${{ needs.build-linux-arm.outputs.build_version }}.tar.gz
        env:
          # GITHUB_TOKEN é fornecido automaticamente pelo GitHub Actions para autenticação
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}